<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OpenAPI on Baywet's blog</title><link>https://baywet.github.io/tags/openapi/</link><description>Recent content in OpenAPI on Baywet's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>vbiret+blog@outlook.com (Vincent Biret)</managingEditor><webMaster>vbiret+blog@outlook.com (Vincent Biret)</webMaster><lastBuildDate>Sat, 01 Oct 2022 10:28:00 +0000</lastBuildDate><atom:link href="https://baywet.github.io/tags/openapi/index.xml" rel="self" type="application/rss+xml"/><item><title>Lessons learned from API client generation - 09 Conclusion</title><link>https://baywet.github.io/lessons-from-api-client-generation-conclusion/</link><pubDate>Sat, 01 Oct 2022 10:28:00 +0000</pubDate><author>vbiret+blog@outlook.com (Vincent Biret)</author><guid>https://baywet.github.io/lessons-from-api-client-generation-conclusion/</guid><description>This is the final entry in our series. First, I’d like to thank the Microsoft Graph DevX team for all the hard work to make Kiota a reality over the last 2 years. Special thanks to Darrel Miller for mentoring me on JSON schema and OpenAPI as well as the deep and open technical discussions.
Then, I’d like to thank the organizing committee for the API specifications conference for inviting me to speak about this topic, which sparked a bunch of interesting follow ups during the event.</description></item><item><title>Lessons learned from API client generation - 08 Composed types</title><link>https://baywet.github.io/lessons-from-api-client-generation-composed-types/</link><pubDate>Sat, 01 Oct 2022 10:27:00 +0000</pubDate><author>vbiret+blog@outlook.com (Vincent Biret)</author><guid>https://baywet.github.io/lessons-from-api-client-generation-composed-types/</guid><description>Seventh pattern of our series: composed types. JSON schema defines 3 main ways of composing types:
allOf: the data must validate all the schemas described in the collection. This is often mapped to inheritance in Object Oriented Programming (OOP) although it wasn’t designed for that purpose. anyOf: the data must validate one or more of the schemas. Often mapped to inclusive unions/intersections. (&amp;amp; sign in TypeScript) oneOf: the data must validate a single schema in the collection.</description></item><item><title>Lessons learned from API client generation - 07 Nullable</title><link>https://baywet.github.io/lessons-from-api-client-generation-nullable/</link><pubDate>Sat, 01 Oct 2022 10:26:00 +0000</pubDate><author>vbiret+blog@outlook.com (Vincent Biret)</author><guid>https://baywet.github.io/lessons-from-api-client-generation-nullable/</guid><description>Sixth pattern of our series, nullable types. This one will be harder to crack. I’ve concluded that marking scalar types as nullable for the purpose of API client generation is not a useful piece of information. While the property might not be nullable on the service itself, it might not be selected by the client, or filtered out for security reasons, and the client needs to convey that information to the application.</description></item><item><title>Lessons learned from API client generation - 06 Paging</title><link>https://baywet.github.io/lessons-from-api-client-generation-pagin/</link><pubDate>Sat, 01 Oct 2022 10:25:00 +0000</pubDate><author>vbiret+blog@outlook.com (Vincent Biret)</author><guid>https://baywet.github.io/lessons-from-api-client-generation-pagin/</guid><description>Fifth pattern of our series: paging conventions. The following examples describes a page as with a value property (array) which will contain the resulting items, and a nextLink property which contains the link to the next page.
paths: /path: get: summary: Get description: Get operationId: get tags: - api1 responses: &amp;#39;200&amp;#39;: description: OK content: application/json: schema: type: object properties: value: type: array items: type: string nextLink: type: string nullable: true x-ms-pageable: nextLinkName: nextLink itemName: value operationName: get This is missing a lot of information to make the life of the client easier:</description></item><item><title>Lessons learned from API client generation - 05 Naming conventions</title><link>https://baywet.github.io/lessons-from-api-client-generation-naming-conventions/</link><pubDate>Sat, 01 Oct 2022 10:24:00 +0000</pubDate><author>vbiret+blog@outlook.com (Vincent Biret)</author><guid>https://baywet.github.io/lessons-from-api-client-generation-naming-conventions/</guid><description>Fourth pattern of our series: naming conventions for unnamed things. When Kiota generates models for requests bodies and responses, two cases are possible: either the type is defined in a reusable component schema, which means the component is named and Kiota can use that name for the generated model. Or the type is defined inline, in which case Kiota needs to rely on naming conventions.
paths: /path: get: summary: Get description: Get operationId: get tags: - api1 responses: &amp;#39;200&amp;#39;: description: OK content: application/json: schema: type: object # PathResponse properties: inlineProperty: type: object # PathResponseInlinePropertyModel properties: subInlineProp: type: object # PathResponseInlinePropertyModelSubInlinePropModel properties: subSubInlineProp: type: string inlineArrayProperty: type: array items: type: object # PathResponseInlineArrayPropertyModel properties: subInlineProp: type: string In the snippet above the generated types will be named according to the path segment name and according to naming suffixes always appended to the parent type name.</description></item><item><title>Lessons learned from API client generation - 04 Type and format</title><link>https://baywet.github.io/lessons-from-api-client-generation-type-format/</link><pubDate>Sat, 01 Oct 2022 10:23:00 +0000</pubDate><author>vbiret+blog@outlook.com (Vincent Biret)</author><guid>https://baywet.github.io/lessons-from-api-client-generation-type-format/</guid><description>Third pattern of our series looking at how we could improve the OpenAPI specification for the purpose of code generation. Today we’ll look at type and formats which are crucial to generate accurate and useful clients.
components: schemas: Model: type: object properties: noType: properties: subProp: type: string impossibleCombination: type: string format: int32 In the snippet above, for the first example properties are defined, which hints the type should be an object, but the type property is not set to object.</description></item><item><title>Lessons learned from API client generation - 03 Collections</title><link>https://baywet.github.io/lessons-from-api-client-generation-collections/</link><pubDate>Sat, 01 Oct 2022 10:22:00 +0000</pubDate><author>vbiret+blog@outlook.com (Vincent Biret)</author><guid>https://baywet.github.io/lessons-from-api-client-generation-collections/</guid><description>Second pattern of our series: collections.
components: schemas: Model: type: object properties: stringArray: type: array items: type: string stringArrayNoType: items: type: string arrayOfUnknown: type: array items: {} In the above snippet, stringArray describes an array of string values. While this works well for the purpose of generating code, it is not very specific. It is assumed that an array will be enough for the application developer, and while that might be the case, signaling generator whether to use a basic array or a more advanced data structure would help for scenarios where the client application cannot have duplicate entries, or needs to quickly find one of the entries, or needs to do some sorting, etc.</description></item><item><title>Lessons learned from API client generation - 02 Enumerations</title><link>https://baywet.github.io/lessons-from-api-client-generation-enums/</link><pubDate>Sat, 01 Oct 2022 10:21:00 +0000</pubDate><author>vbiret+blog@outlook.com (Vincent Biret)</author><guid>https://baywet.github.io/lessons-from-api-client-generation-enums/</guid><description>First pattern of our series: enumerations. They are essential to any programing language to describe a discrete set of options. Consider the following examples:
components: schemas: Model: type: object properties: enumString: type: string enum: - value1 - value2 enumInteger: type: integer enum: - 1 - 2 enumBoolean: type: boolean enum: - true - false EnumString describes two possible values, however it’s missing a lot of information:
We can’t specify a different serialization value from the symbol.</description></item><item><title>Lessons learned from API client generation - 01 Introduction</title><link>https://baywet.github.io/lessons-from-api-client-generation-intro/</link><pubDate>Sat, 01 Oct 2022 10:20:00 +0000</pubDate><author>vbiret+blog@outlook.com (Vincent Biret)</author><guid>https://baywet.github.io/lessons-from-api-client-generation-intro/</guid><description>Over the last two years I’ve been working on a modern client generator for OpenAPI described APIs: project kiota. Kiota generates models and chained methods to allow developers to build requests for any REST API. The generated clients handle serialization, deserialization, authentication, retrying transient errors, following (or not) redirections and much more. Using a generated client saves developers from having to re-implement those aspects and enables them to focus on the core logic of the application.</description></item><item><title>Speaking at Caribbean Developer Conference 2022</title><link>https://baywet.github.io/speaking-at-cdc-2022/</link><pubDate>Sun, 18 Sep 2022 12:20:00 +0000</pubDate><author>vbiret+blog@outlook.com (Vincent Biret)</author><guid>https://baywet.github.io/speaking-at-cdc-2022/</guid><description>I’m honoured to announce that I’ve been selected to speak at the Caribbean Developer Conference 2022 happening in Punta Cana Nov 3-5th. This is the first time I’ll be speaking at this event, but I’ve heard lots of good things about it from people who previously spoke there.
I’ll be presenting “Turbocharge your API integration with Microsoft Kiota” where I’ll be introducing through lots of demonstrations how you can generate a client generated for any OpenAPI described API using Microsoft Kiota and other tools.</description></item><item><title>Speaking at CollabDays Belgium 2022</title><link>https://baywet.github.io/speaking-at-collabdays-belgium-2022/</link><pubDate>Sun, 11 Sep 2022 12:20:00 +0000</pubDate><author>vbiret+blog@outlook.com (Vincent Biret)</author><guid>https://baywet.github.io/speaking-at-collabdays-belgium-2022/</guid><description>I’m honoured to announce that I’ve been selected to speak at the CollabDays Belgium 2022 (formerly SPS Events, aka SharePoint Saturday) happening in Brussels Saturday 15th of October. This event is dear to my heart as it’s one of the first international events I ever got to speak at, it always attracts a great crowd and brings together internationally regarded speakers.
I’ll be presenting “Turbocharge your API integration with Microsoft Kiota” where I’ll be introducing through lots of demonstrations how you can generate a client generated for any OpenAPI described API using Microsoft Kiota and other tools.</description></item><item><title>Speaking at the API specification conference 2022</title><link>https://baywet.github.io/speaking-at-api-specification-conf-2022/</link><pubDate>Sun, 04 Sep 2022 12:20:00 +0000</pubDate><author>vbiret+blog@outlook.com (Vincent Biret)</author><guid>https://baywet.github.io/speaking-at-api-specification-conf-2022/</guid><description>I’m extremely pleased to announce I’ll be speaking at the API specification conference 2022 in San Francisco, Sept 19-21st. During “Lessons learned from client generation, gaps and suggestions to address them”, we’ll be reviewing my 2 years experience building an OpenAPI based client generator and trying to identify solutions to ease up code generation, leading to better clients.
The API specification conference is the first in person event I’ll be presenting at in almost 3 years, I’m really excited and a bit nervous (do I even remember how to do this anymore?</description></item></channel></rss>